// -*- C++ -*-
//
// Package:    TrackPropagation/SteppingHelixPropagator
// Class:      SteppingHelixPropagatorAnalyzer
// 
/**\class SteppingHelixPropagatorAnalyzer 
   Description: Analyzer of SteppingHelixPropagator performance

   Implementation:
   Use simTracks and simVertices as initial points. For all  muon PSimHits in the event 
   extrapolate/propagate from the previous point (starting from a vertex) 
   to the hit position (detector surface).
   Fill an nTuple (could've been an EventProduct) with expected (given by the propagator) 
   and actual (PSimHits)
   positions of a muon in the detector.
*/
//
// Original Author:  Vyacheslav Krutelyov
//         Created:  Fri Mar  3 16:01:24 CST 2006
// $Id: SteppingHelixPropagatorAnalyzer.cc,v 1.24 2012/09/19 20:31:29 wdd Exp $
//
//


// system include files
#include <memory>

// user include files
#include "FWCore/Framework/interface/Frameworkfwd.h"
#include "FWCore/Framework/interface/EDAnalyzer.h"
#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/ESHandle.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/MessageLogger/interface/MessageLogger.h"

#include "DataFormats/Common/interface/Handle.h"

#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/Utilities/interface/InputTag.h"

#include "DataFormats/GeometrySurface/interface/Cylinder.h"
#include "DataFormats/GeometrySurface/interface/Plane.h"

#include "Geometry/CommonDetUnit/interface/GlobalTrackingGeometry.h"
#include "Geometry/Records/interface/GlobalTrackingGeometryRecord.h"

#include "Geometry/CSCGeometry/interface/CSCGeometry.h"
#include "Geometry/RPCGeometry/interface/RPCGeometry.h"
//#include "Geometry/RPCGeometry/interface/RPCRoll.h"
#include "Geometry/Records/interface/MuonGeometryRecord.h"

#include "Geometry/CommonDetUnit/interface/GeomDetUnit.h"


#include "MagneticField/Engine/interface/MagneticField.h"
#include "MagneticField/Records/interface/IdealMagneticFieldRecord.h"

#include "TrackingTools/Records/interface/TrackingComponentsRecord.h"

#include "SimDataFormats/TrackingHit/interface/PSimHit.h"
#include "SimDataFormats/TrackingHit/interface/PSimHitContainer.h"
#include "SimDataFormats/Track/interface/SimTrack.h"
#include "SimDataFormats/Track/interface/SimTrackContainer.h"
#include "SimDataFormats/Vertex/interface/SimVertex.h"
#include "SimDataFormats/Vertex/interface/SimVertexContainer.h"

#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "DataFormats/MuonDetId/interface/DTWireId.h"
#include "DataFormats/MuonDetId/interface/RPCDetId.h"
#include "DataFormats/MuonDetId/interface/CSCDetId.h"

#include "CLHEP/Random/RandFlat.h"
#include "CLHEP/Units/GlobalPhysicalConstants.h"
//#include "CLHEP/Matrix/DiagMatrix.h"

#include "TrackPropagation/SteppingHelixPropagator/interface/SteppingHelixPropagator.h"
#include "TrackPropagation/SteppingHelixPropagator/interface/SteppingHelixStateInfo.h"

#include "DataFormats/TrackReco/interface/TrackFwd.h"
#include "DataFormats/TrackReco/interface/Track.h"

#include "DataFormats/Math/interface/deltaR.h"

#include "TLorentzVector.h"
#include "TRandom1.h"

#include "TFile.h"
#include "TTree.h"



#include <map>

//#include "MuProp_v2.h"
#include <TH2.h>
#include <TProfile.h>
#include <TStyle.h>
#include <TCanvas.h>
#include <TLegend.h>

#include "TVector2.h"
#include "TVector3.h"
#include "TLorentzVector.h"
#include <iostream>
//#include "CMSStyle.C"
#include "TStyle.h"
#include "TMath.h"
//
// class decleration
//

class SteppingHelixPropagatorAnalyzer : public edm::EDAnalyzer {
public:
  explicit SteppingHelixPropagatorAnalyzer(const edm::ParameterSet&);
  ~SteppingHelixPropagatorAnalyzer();


  virtual void analyze(const edm::Event&, const edm::EventSetup&);
  virtual void endJob();
  void beginJob();

protected:
  struct GlobalSimHit {
    const PSimHit* hit;
    const Surface* surf;
    DetId id;
    CLHEP::Hep3Vector r3;
    CLHEP::Hep3Vector p3;
  };


  void loadNtVars(int ind, int eType,  int pStatus, 
		  int id,//defs offset: 0 for R, 1*3 for Z and, 2*3 for P
		  const CLHEP::Hep3Vector& p3, const CLHEP::Hep3Vector& r3, 
		  const CLHEP::Hep3Vector& p3R, const CLHEP::Hep3Vector& r3R, 
		  int charge, const AlgebraicSymMatrix66& cov);

  void loadNtVarsDavid(int ind, int eType,  int pStatus, 
		       int id,//defs offset: 0 for R, 1*3 for Z and, 2*3 for P
		       const CLHEP::Hep3Vector& p3, const CLHEP::Hep3Vector& r3, const CLHEP::Hep3Vector& r3S, 
		       const CLHEP::Hep3Vector& p3R, const CLHEP::Hep3Vector& r3R, 
		       bool Matched,
		       const CLHEP::Hep3Vector& p3Reco, const CLHEP::Hep3Vector& r3Reco, 
		       int charge, const AlgebraicSymMatrix66& cov, const AlgebraicSymMatrix66& covReco, int NHits,
		       const CLHEP::Hep3Vector& p3_B0, const CLHEP::Hep3Vector& r3_B0,const AlgebraicSymMatrix66& covReco_B0);

  FreeTrajectoryState getFromCLHEP(const CLHEP::Hep3Vector& p3, const CLHEP::Hep3Vector& r3, 
				   int charge, const AlgebraicSymMatrix66& cov,
				   const MagneticField* field);
  FreeTrajectoryState getFromCLHEP(const CLHEP::Hep3Vector& p3, const CLHEP::Hep3Vector& r3, 
				   int charge, const AlgebraicSymMatrix55& cov,
				   const MagneticField* field);

  void getFromFTS(const FreeTrajectoryState& fts,
		  CLHEP::Hep3Vector& p3, CLHEP::Hep3Vector& r3, 
		  int& charge, AlgebraicSymMatrix66& cov);

  void addPSimHits(const edm::Event& iEvent,
		   const std::string instanceName, 
		   const edm::ESHandle<GlobalTrackingGeometry>& geom,
		   std::vector<SteppingHelixPropagatorAnalyzer::GlobalSimHit>& hits) const;

private:
  // ----------member data ---------------------------
  TFile* ntFile_;
  TTree* tr_;

  TH1F *Eta_h;  TH1F *Eta_gen_h;
  TH2F *z_r_hits; 
  TCanvas *c1;
  int nPoints_;
  int q_[1000];
  int eType_[1000];
  int pStatus_[1000][3];
  float p3_[1000][9];
  float r3_[1000][9];
  float r3S_[1000][9];
  int id_[1000];
  float p3R_[1000][3];
  float r3R_[1000][3];
  bool Matched_[1000];
  float p3Reco_[1000][3];
  float r3Reco_[1000][3];
  float covFlat_[1000][21];
  float covRecoFlat_[1000][21];
  float p3_B0_[1000][3];
  float r3_B0_[1000][3];
  float covB0Flat_[1000][21];
  int NHits_[1000];
  bool debug_;
  int run_;
  int event_;

  int trkIndOffset_;

  bool doneMapping_;

  bool radX0CorrectionMode_;

  bool testPCAPropagation_;

  bool ntupleTkHits_;

  bool startFromPrevHit_;

  bool DoDavidsVersion_;

  bool UseOuter_;

  std::string g4SimName_;
  edm::InputTag simTracksTag_;
  edm::InputTag simVertexesTag_;
};

//
// constants, enums and typedefs
//

//
// static data member definitions
//

//
// constructors and destructor
//
SteppingHelixPropagatorAnalyzer::SteppingHelixPropagatorAnalyzer(const edm::ParameterSet& iConfig) :
  simTracksTag_(iConfig.getParameter<edm::InputTag>("simTracksTag")),
  simVertexesTag_(iConfig.getParameter<edm::InputTag>("simVertexesTag"))
{
  //now do what ever initialization is needed

  ntFile_ = new TFile(iConfig.getParameter<std::string>("NtFile").c_str(), "recreate");
  tr_ = new TTree("MuProp", "MuProp");
  tr_->Branch("nPoints", &nPoints_, "nPoints/I");
  tr_->Branch("q", q_, "q[nPoints]/I");
  tr_->Branch("pStatus", pStatus_, "pStatus[nPoints][3]/I");
  tr_->Branch("p3", p3_, "p3[nPoints][9]/F");
  tr_->Branch("r3", r3_, "r3[nPoints][9]/F");
  tr_->Branch("r3S", r3S_, "r3S[nPoints][9]/F");
  tr_->Branch("id", id_, "id[nPoints]/I");
  tr_->Branch("p3R", p3R_, "p3R[nPoints][3]/F");
  tr_->Branch("r3R", r3R_, "r3R[nPoints][3]/F");
  tr_->Branch("Matched", Matched_, "Matched[nPoints]/O");
  tr_->Branch("p3Reco", p3Reco_, "p3Reco[nPoints][3]/F");
  tr_->Branch("r3Reco", r3Reco_, "r3Reco[nPoints][3]/F");
  tr_->Branch("covFlat", covFlat_, "covFlat[nPoints][21]/F");
  tr_->Branch("covRecoFlat", covRecoFlat_, "covRecoFlat[nPoints][21]/F");
  tr_->Branch("NHits", NHits_, "NHits[nPoints]/I");
  tr_->Branch("p3_B0", p3_B0_, "p3_B0[nPoints][3]/F");
  tr_->Branch("r3_B0", r3_B0_, "r3_B0[nPoints][3]/F");
  tr_->Branch("covB0Flat", covB0Flat_, "covB0Flat[nPoints][21]/F");
  tr_->Branch("run", &run_, "run/I");
  tr_->Branch("event_", &event_, "event/I");

  trkIndOffset_ = iConfig.getParameter<int>("trkIndOffset");
  debug_ = iConfig.getParameter<bool>("debug");
  radX0CorrectionMode_ = iConfig.getParameter<bool>("radX0CorrectionMode");

  testPCAPropagation_ = iConfig.getParameter<bool>("testPCAPropagation");

  ntupleTkHits_ = iConfig.getParameter<bool>("ntupleTkHits");

  startFromPrevHit_ = iConfig.getParameter<bool>("startFromPrevHit");

  DoDavidsVersion_ = iConfig.getParameter<bool>("DoDavidsVersion");

  UseOuter_ = iConfig.getParameter<bool>("UseOuter");

  g4SimName_ = iConfig.getParameter<std::string>("g4SimName");

  //initialize the variables
  for(int i=0;i<1000;++i){
    q_[i] = 0;
    eType_[i] = 0;
    for(int j=0;j<3;++j) pStatus_[i][j] = 0;
    for(int j=0;j<9;++j) p3_[i][j] = 0;
    for(int j=0;j<9;++j) r3_[i][j] = 0;
    id_[i] = 0;
    for(int j=0;j<3;++j)p3R_[i][j] = 0;
    for(int j=0;j<3;++j) r3R_[i][j] = 0;
    for(int j=0;j<21;++j) covFlat_[i][j] = 0;
    for(int j=0;j<3;++j)p3Reco_[i][j] = 0;
    for(int j=0;j<3;++j) r3Reco_[i][j] = 0;
    for(int j=0;j<21;++j) covRecoFlat_[i][j] = 0;
    NHits_[i] = 0;

  }

}

void SteppingHelixPropagatorAnalyzer::beginJob(){
  Eta_h = new TH1F("Eta_h"      , "#eta reco"   , 100, 0., 4.5 );
  Eta_gen_h = new TH1F("Eta_gen_h"      , "#eta gen"   , 100, 0., 4.5 );
  z_r_hits = new TH2F("z_r_hits", "z-R position of all tracks' hits", 350, 0., 350, 120, 0., 120.); 
  //c1 = new TCanvas("c1", "", 600, 600);
  //c1->SetLogy();
}


SteppingHelixPropagatorAnalyzer::~SteppingHelixPropagatorAnalyzer()
{

}


//
// member functions
//

// ------------ method called to produce the data  ------------
void
SteppingHelixPropagatorAnalyzer::analyze(const edm::Event& iEvent, const edm::EventSetup& iSetup)
//setting up pointers to the "Event" category and "EventSetup" categories in the root file
{

  constexpr char const*metname = "SteppingHelixPropagatorAnalyzer";
  (void)metname;
  using namespace edm;

  ESHandle<MagneticField> bField;
  iSetup.get<IdealMagneticFieldRecord>().get(bField);

  //Getting the objects called "SteppingHelixPropagatorAny" from the Propagator mother class
  //We'll need to reference the specific propagator type later...
  ESHandle<Propagator> shProp;
  //iSetup.get<TrackingComponentsRecord>().get("SteppingHelixPropagatorAny", shProp);
  iSetup.get<TrackingComponentsRecord>().get("SteppingHelixPropagatorAlong", shProp);
  ESHandle<Propagator> shPropAny;
  //iSetup.get<TrackingComponentsRecord>().get("SteppingHelixPropagatorAny", shPropAny);
  iSetup.get<TrackingComponentsRecord>().get("SteppingHelixPropagatorAlong", shPropAny);

  //I'm adding one more iteration of that as well
  ESHandle<Propagator> shPropAny_ForMe;
  //iSetup.get<TrackingComponentsRecord>().get("SteppingHelixPropagatorAny", shPropAny_ForMe);
  iSetup.get<TrackingComponentsRecord>().get("SteppingHelixPropagatorAlong", shPropAny_ForMe);

  ESHandle<GlobalTrackingGeometry> geomESH;
  iSetup.get<GlobalTrackingGeometryRecord>().get(geomESH);
  if (debug_){
    LogTrace(metname)<<"Got GlobalTrackingGeometry "<<std::endl;
    std::cout<<"Got GlobalTrackingGeometry "<<std::endl;
  }

  //   ESHandle<CSCGeometry> cscGeomESH;
  //   iSetup.get<MuonGeometryRecord>().get(cscGeomESH);
  //   if (debug_){
  //     std::cout<<"Got CSCGeometry "<<std::endl;
  //   }

  //   ESHandle<RPCGeometry> rpcGeomESH;
  //   iSetup.get<MuonGeometryRecord>().get(rpcGeomESH);
  //   if (debug_){
  //     std::cout<<"Got RPCGeometry "<<std::endl;
  //   }

  run_ = (int)iEvent.id().run();
  event_ = (int)iEvent.id().event();
  if (debug_){
    LogTrace(metname)<<"Begin for run:event =="<<run_<<":"<<event_<<std::endl;
  }


    //David's functionality
    
  if (DoDavidsVersion_){
    using namespace reco;
    Handle<GenParticleCollection> genParticles;
    iEvent.getByLabel<GenParticleCollection>("genParticles", genParticles);

    Handle <TrackCollection > generalTracks;
    iEvent.getByLabel <TrackCollection> ("generalTracks", generalTracks);

    unsigned int gensize=genParticles->size();
    unsigned int recosize=generalTracks->size();
    std::cout<<gensize<<std::endl;
    std::cout<<recosize<<std::endl;
    double numtotalmuon= 0, numindisk = 0;
    //===========  Matching a track to each gen particle and storing a map of tracks with their associated gentracks
    std::map<unsigned int, const Track*> TracksbyGenTrack;
    std::cout<<"General Tracks = "<<generalTracks->size()<<std::endl;
    for (std::vector<Track>::const_iterator thisTrack = generalTracks->begin();
	 thisTrack != generalTracks->end(); ++thisTrack){
      Eta_h->Fill(thisTrack->eta());

//       trackingRecHit_iterator rhit = thisTrack->recHitsBegin(), rhend = thisTrack->recHitsEnd(); 
//       for(; rhit!=rhend; ++rhit) {
// 	const GeomDet* geomDet = geomESH->idToDet( (*rhit)->geographicalId() );
// 	GlobalPoint glpt=geomDet->toGlobal( (*rhit)->localPosition() );
// 	z_r_hits->Fill(glpt.z(), sqrt(glpt.x()*glpt.x() + glpt.y()*glpt.y()));
//       }

      Double_t delR=1; //change for when we use pileup
      //std::cout<<gensize<<std::endl;
      for(unsigned int i=0; i<gensize; ++i) {
	const reco::GenParticle& CurrentParticle=(*genParticles)[i];
	if ( (CurrentParticle.status()==1) && ( (CurrentParticle.pdgId()==13)  || (CurrentParticle.pdgId()==-13) ) ){

	  if (deltaR(thisTrack->eta(),thisTrack->phi(),CurrentParticle.eta(),CurrentParticle.phi()) < delR) {
	    delR=deltaR(thisTrack->eta(),thisTrack->phi(),CurrentParticle.eta(),CurrentParticle.phi());
	    TracksbyGenTrack[i] = &*thisTrack;
	    //std::cout<<"    Have a matching track"<<std::endl;
	  }
	  else {
	    //std::cout<<"No track less than 999"<<std::endl;
	    TracksbyGenTrack[i] = 0;
	  }
	}
	else {
	  //std::cout<<"No muon"<<std::endl;
	}
      }
    }

    //Propagating each gentrack and smearing it
    TRandom1 * Rand = new TRandom1();
    //std::cout<<gensize<<std::endl;
    //double numfailing = 0;
    double total = 0, numout = 0, numin = 0;
    int PUCloserCount = 0;
    for(unsigned int i=0; i<gensize; ++i) {
      const reco::GenParticle& CurrentParticle=(*genParticles)[i];
      Eta_gen_h->Fill(CurrentParticle.eta());
      //if (gensize != TracksbyGenTrack.size())continue;//remove this later
      //std::cout<<CurrentParticle.status()<<", "<<CurrentParticle.pdgId()<<std::endl;
      if ( (CurrentParticle.status()==1) && ( (CurrentParticle.pdgId()==13)  || (CurrentParticle.pdgId()==-13) ) ){
	numtotalmuon++;
	  std::cout<<"a gen track"<<std::endl;
	float zSign  = CurrentParticle.pz()/fabs(CurrentParticle.pz());
	float zValue = 560. * zSign;
	//if (CurrentParticle.pz() < 0.) std::cout<<"NEGATIVE"<<std::endl;
	//if (CurrentParticle.pz() > 0.) std::cout<<"POSITIVE"<<std::endl;
	//std::cout<<zValue<<std::endl;
	Plane *plane = new Plane(Surface::PositionType(0,0,zValue),Surface::RotationType());
	TLorentzVector Momentum;
	Momentum.SetPtEtaPhiM(CurrentParticle.pt()
			      ,CurrentParticle.eta()
			      ,CurrentParticle.phi()
			      ,CurrentParticle.mass());
	//std::cout<<"ETA = "<<CurrentParticle.eta()<<std::endl;
	//=====  Making a straight line from the gen particle's track ====//



	Double_t P_mag = sqrt(CurrentParticle.px()*CurrentParticle.px()+CurrentParticle.py()*CurrentParticle.py()+CurrentParticle.pz()*CurrentParticle.pz());
	Double_t Xhat = CurrentParticle.px()/P_mag;
	Double_t Yhat = CurrentParticle.py()/P_mag;
	Double_t Zhat = CurrentParticle.pz()/P_mag;

	CLHEP::Hep3Vector r3straight = CLHEP::Hep3Vector(0,0,0);
	//if (zValue*Zhat > 0){

	//r3straight = (Xhat*(zValue/Zhat) ,Yhat*(zValue/Zhat) ,zValue);
	r3straight.setX(Xhat*(zValue/Zhat));
	r3straight.setY(Yhat*(zValue/Zhat));
	r3straight.setZ(zValue);


	//std::cout<<Xhat<<", "<<Yhat<<", "<<Zhat<<std::endl;
	//std::cout<<r3straight.x()<<", "<<r3straight.y()<<", "<<r3straight.z()<<std::endl;
	//}

	//==================================================//

	
	CLHEP::Hep3Vector p3gen(Momentum.Px(), Momentum.Py(), Momentum.Pz());
	
	CLHEP::Hep3Vector r3gen = CLHEP::Hep3Vector(CurrentParticle.vertex().x()
						    ,CurrentParticle.vertex().y()
						    ,CurrentParticle.vertex().z());
	
	AlgebraicSymMatrix66 covGen = AlgebraicMatrixID(); 
	covGen *= 1e-20; // initialize to sigma=1e-10 .. should get overwhelmed by MULS
	AlgebraicSymMatrix66 covFinal;
	//std::cout<<"1"<<std::endl;
	//int chargeGen =  CurrentParticle.pdgId() > 0 ? -1 : 1;
	int chargeGen =  CurrentParticle.charge(); 

	//std::cout << CurrentParticle.pdgId() << " vs " << CurrentParticle.charge() << std::endl;
	FreeTrajectoryState initstate = getFromCLHEP(p3gen, r3gen, chargeGen, covGen, &*bField);
	

	int pStatus = 0;

	//std::cout<<"2"<<std::endl;
	
	SteppingHelixStateInfo startstate(initstate);
	SteppingHelixStateInfo laststate;
	
	const SteppingHelixPropagator* shPropAny_MyExperiment = 
	  dynamic_cast<const SteppingHelixPropagator*>(&*shPropAny_ForMe);
	
	laststate = shPropAny_MyExperiment->propagate(startstate, *plane);
	
	FreeTrajectoryState finalstate;
	laststate.getFreeState(finalstate);
	
	CLHEP::Hep3Vector p3Final, r3Final;
	getFromFTS(finalstate, p3Final, r3Final, chargeGen, covFinal);
	
	//Double_t rho = sqrt(r3Final.x()*r3Final.x()+r3Final.y()*r3Final.y());
	//rho is a misnomer here, what is meant is "r"
	Double_t rho = r3Final.perp();
	Double_t phi = r3Final.phi();

	Double_t drhodx = r3Final.x()/rho;
	Double_t drhody = r3Final.y()/rho;
	Double_t dphidx = -r3Final.y()/(rho*rho);
	Double_t dphidy = r3Final.x()/(rho*rho);
	
	Double_t sigmarho = sqrt( drhodx*drhodx*covFinal(0,0)+
				  drhody*drhody*covFinal(1,1)+
				  drhodx*drhody*2*covFinal(0,1) );

	Double_t sigmaphi = sqrt( dphidx*dphidx*covFinal(0,0)+
				  dphidy*dphidy*covFinal(1,1)+
				  dphidx*dphidy*2*covFinal(0,1) );
	

	Double_t newrho = rho + Rand->Gaus(0,sigmarho);//Add smearing here
	Double_t newphi = phi + Rand->Gaus(0,sigmaphi);
	//std::cout<<Rand->Gaus(0,sigmarho)<<std::endl;
	CLHEP::Hep3Vector SmearedVector(1,1,1);
					
					
	//SmearedVector.setMag(newrho);
	SmearedVector.setPerp(newrho);  SmearedVector.setPhi(newphi);  SmearedVector.setZ(r3Final.z());


	//-------------------Smearing the direction as well

	
	// Double_t sigma_px = covFinal(3,3);
	// Double_t sigma_py = covFinal(4,4);
	// Double_t sigma_pz = covFinal(5,5);

	// Double_t new_px = p3Final.x() + Rand->Gaus(0,sigma_px);//Add smearing here
	// Double_t new_py = p3Final.y() + Rand->Gaus(0,sigma_py);
	// Double_t new_pz = p3Final.z() + Rand->Gaus(0,sigma_pz);
	// //std::cout<<Rand->Gaus(0,sigmarho)<<std::endl;
	// CLHEP::Hep3Vector SmearedDirection(new_px,new_py,new_pz);

	//================Now for each smeared "sim" hit I propagate each track out

	float RealDistance = 0;
	float FakeDistance = 9999;

	for (std::vector<Track>::const_iterator thisTrack = generalTracks->begin();
	     thisTrack != generalTracks->end(); ++thisTrack){
	  //std::cout<<"Starting a reco thing"<<std::endl;
	  //if (thisTrack->pz() > 0.0) continue;
	  nPoints_ = 0;
	  CLHEP::Hep3Vector p3reco, r3reco;
	  if (!UseOuter_){
	    p3reco = CLHEP::Hep3Vector(thisTrack->px(), thisTrack->py(), thisTrack->pz());
	    r3reco = CLHEP::Hep3Vector(thisTrack->vx(), thisTrack->vy(), thisTrack->vz());
	  }
	  else if (UseOuter_){
	    p3reco = CLHEP::Hep3Vector(thisTrack->outerPx(), thisTrack->outerPy(), thisTrack->outerPz());
	    r3reco = CLHEP::Hep3Vector(thisTrack->outerX(), thisTrack->outerY(), thisTrack->outerZ());

	    // p3reco = CLHEP::Hep3Vector(thisTrack->innerMomentum().x(), thisTrack->innerMomentum().y(), thisTrack->innerMomentum().z());
	    //  r3reco = CLHEP::Hep3Vector(thisTrack->innerPosition().x(), thisTrack->innerPosition().y(), thisTrack->innerPosition().z());
	    
	  }
	  //std::cout<<"Loaded"<<std::endl;
	  //std::cout<<"Vertex = "<<thisTrack->vx()<<", "<<thisTrack->vy()<<", "<<thisTrack->vz()<<std::endl;
	  //std::cout<<"Outer = "<<thisTrack->outerX()<<", "<<thisTrack->outerY()<<", "<<thisTrack->outerZ()<<std::endl;
	  //std::cout<<"R = "<<r3reco.x()<<", "<<r3reco.y()<<", "<<r3reco.z()<<std::endl;


	  AlgebraicSymMatrix66 covReco;// = AlgebraicMatrixID(); 
	  AlgebraicSymMatrix66 covRecoB0;// = AlgebraicMatrixID(); 
	  //covReco *= 1e-20; 
	  AlgebraicSymMatrix66 covFinalReco;
	  AlgebraicSymMatrix66 covFinalRecoB0;

	  int chargeReco = thisTrack->charge(); 
	  //if (chargeReco >0)std::cout<<"POSITIVE"<<std::endl;
	  //if (chargeReco <0)std::cout<<"NEGATIVE"<<std::endl;

	  //std::cout<<"Precheck ZERO"<<std::endl;
	  //std::cout<<i<<std::endl;
	  //bool isMuonTrack=true;
	  bool isMuonTrack=false;
	  int NumHits = 0;
	  if (TracksbyGenTrack[i]!=0) {
	    if ( fabs(thisTrack->px() - TracksbyGenTrack[i]->px()) < 1e-6 &&
		 fabs(thisTrack->py() - TracksbyGenTrack[i]->py()) < 1e-6 &&
		 fabs(thisTrack->pz() - TracksbyGenTrack[i]->pz()) < 1e-6    ) {
	      isMuonTrack = true;
	      NumHits = thisTrack->numberOfValidHits();
	      //std::cout<<"    Found a matching track"<<std::endl;
	      //if (chargeReco*chargeGen < 0) std::cout<<"OPPOSITE"<<std::endl;
	      //if (chargeReco*chargeGen > 0) std::cout<<"SAME"<<std::endl;
	      //chargeReco = chargeGen;
	    }
	  }

	  AlgebraicSymMatrix55 covReco_curv;
	  if (!UseOuter_)  covReco_curv = thisTrack->covariance();
	  else if (UseOuter_)  covReco_curv = thisTrack->outerStateCovariance();



	  
	  FreeTrajectoryState initrecostate = getFromCLHEP(p3reco, r3reco, chargeReco, covReco_curv, &*bField);


	  CLHEP::Hep3Vector p3B0, r3B0;
	  p3B0 = CLHEP::Hep3Vector(thisTrack->px(), thisTrack->py(), thisTrack->pz());
	  r3B0 = CLHEP::Hep3Vector(thisTrack->vx(), thisTrack->vy(), thisTrack->vz());


	  FreeTrajectoryState initrecostate_B0 = getFromCLHEP(p3B0, r3B0, 0, thisTrack->covariance(), &*bField);

	  getFromFTS(initrecostate_B0, p3B0, r3B0, chargeReco, covRecoB0);

	  getFromFTS(initrecostate, p3reco, r3reco, chargeReco, covReco);


	  loadNtVarsDavid(nPoints_, 0, pStatus, 0, p3gen, r3gen,  r3gen, p3gen, r3gen,isMuonTrack,p3reco,r3reco, chargeReco, covGen,covReco,NumHits,p3B0,r3B0,covRecoB0); nPoints_++;    

	
	  SteppingHelixStateInfo startrecostate(initrecostate);
	  SteppingHelixStateInfo lastrecostate;

	  SteppingHelixStateInfo startrecostate_B0(initrecostate_B0);
	  SteppingHelixStateInfo lastrecostate_B0;
	
	  lastrecostate_B0 = shPropAny_MyExperiment->propagate(startrecostate_B0, *plane);


	  lastrecostate = shPropAny_MyExperiment->propagate(startrecostate, *plane);
	
	  FreeTrajectoryState finalrecostate_B0;
	  lastrecostate_B0.getFreeState(finalrecostate_B0);

	  FreeTrajectoryState finalrecostate;
	  lastrecostate.getFreeState(finalrecostate);
	
	  CLHEP::Hep3Vector p3FinalB0, r3FinalB0;
	  getFromFTS(finalrecostate_B0, p3FinalB0, r3FinalB0, chargeReco, covFinalRecoB0);

	  //std::cout<<r3FinalB0.x()<<", "<<r3FinalB0.y()<<", "<<r3FinalB0.z()<<std::endl;


	  CLHEP::Hep3Vector p3FinalReco, r3FinalReco;
	  getFromFTS(finalrecostate, p3FinalReco, r3FinalReco, chargeReco, covFinalReco);

	  
	  double absetaBoundMin = 2.4; 
	  double absetaBoundMax = 4.0; 
	  total++;
	  if (!isMuonTrack) numout++;

	  if( (fabs(r3FinalReco.eta()))<absetaBoundMin || (r3FinalReco.eta())>absetaBoundMax ) {
	    continue; 
	  }
	  if ( r3FinalReco.eta() < 3.6) continue;
	  if (isMuonTrack)numindisk++;
	  if (!isMuonTrack && (r3FinalReco.z()> 550.0)) numin++;
	  loadNtVarsDavid(nPoints_, 0, pStatus, 0, p3Final, r3Final,  r3straight, p3Final, SmearedVector,isMuonTrack, p3FinalReco, r3FinalReco, chargeGen, covFinal, covFinalReco,NumHits,p3FinalB0,r3FinalB0,covFinalRecoB0); nPoints_++;

	  if (isMuonTrack) 
	    {
	      RealDistance = (SmearedVector-r3FinalReco).mag();
	    }
	  if (!isMuonTrack)
	    {
	      if ((SmearedVector-r3FinalReco).mag() < FakeDistance) FakeDistance = (SmearedVector-r3FinalReco).mag();
	    }
	  //std::cout<<"Filling the tree"<<std::endl;
	  if (tr_) {	 tr_->Fill();} //fill this track prop info  
	}
	if (FakeDistance<RealDistance) 
	  {
	    std::cout<<"Found one"<<std::endl;
	    PUCloserCount++;
	  }
      }
    }
    std::cout<<"Fraction closer= "<<PUCloserCount<<std::endl;
    //std::cout<<"Fraction failing = "<<numfailing/total<<std::endl;
    //std::cout<<"Fraction in = "<<numin/(numin+numout)<<std::endl;
    //std::cout<<"number total = "<<numtotalmuon<<std::endl;
    //std::cout<<"number in disk = "<<numindisk<<std::endl;
    //getFromFTS(finalstate, p3F, r3F, charge, covF);
  }//Closing the brackets around David's version

    //=================================================//


  if (!DoDavidsVersion_){//new scope for timing purposes only
  const double FPRP_MISMATCH = 150.;
  //const double FPRP_MISMATCH = 15.;  //This was my change, changed back now
  int pStatus = 0; //1 will be bad


  Handle<SimTrackContainer> simTracks;
  iEvent.getByLabel<SimTrackContainer>(simTracksTag_, simTracks);
  if (! simTracks.isValid() ){
    std::cout<<"No tracks found"<<std::endl;
    return;
  }
  if (debug_){
    LogTrace(metname)<<"Got simTracks of size "<< simTracks->size()<<std::endl;
  }

  Handle<SimVertexContainer> simVertices;
  iEvent.getByLabel<SimVertexContainer>(simVertexesTag_, simVertices);
  if (! simVertices.isValid() ){
    std::cout<<"No tracks found"<<std::endl;
    return;
  }
  if (debug_){
    LogTrace(metname)<<"Got simVertices of size "<< simVertices->size()<<std::endl;
  }
  

  std::vector<GlobalSimHit> allSimHits; allSimHits.clear();

  addPSimHits(iEvent, "MuonDTHits", geomESH, allSimHits);
  addPSimHits(iEvent, "MuonCSCHits", geomESH, allSimHits);
  addPSimHits(iEvent, "MuonRPCHits", geomESH, allSimHits);
  // addPSimHits(iEvent, "TrackerHitsPixelBarrelLowTof", geomESH, allSimHits);
  // addPSimHits(iEvent, "TrackerHitsPixelEndcapLowTof", geomESH, allSimHits);
  // addPSimHits(iEvent, "TrackerHitsTIBLowTof", geomESH, allSimHits);
  // addPSimHits(iEvent, "TrackerHitsTIDLowTof", geomESH, allSimHits);
  // addPSimHits(iEvent, "TrackerHitsTOBLowTof", geomESH, allSimHits);
  // addPSimHits(iEvent, "TrackerHitsTECLowTof", geomESH, allSimHits);

  

  SimTrackContainer::const_iterator tracksCI = simTracks->begin();
  for(; tracksCI != simTracks->end(); tracksCI++){
        int trkPDG = tracksCI->type();
    if (abs(trkPDG) != 13 ) {
      if (debug_){
	LogTrace(metname)<<"Skip "<<trkPDG<<std::endl;
      }
      continue;
    }

   

    CLHEP::Hep3Vector p3T(tracksCI->momentum().x(), tracksCI->momentum().y(), tracksCI->momentum().z());
    if (p3T.mag()< 2.) continue;

    int vtxInd = tracksCI->vertIndex();
    unsigned int trkInd = tracksCI->genpartIndex() - trkIndOffset_;
    CLHEP::Hep3Vector r3T(0.,0.,0.);
    if (vtxInd < 0){
      std::cout<<"Track with no vertex, defaulting to (0,0,0)"<<std::endl;      
    } else {
      r3T = CLHEP::Hep3Vector((*simVertices)[vtxInd].position().x(),
		       (*simVertices)[vtxInd].position().y(),
		       (*simVertices)[vtxInd].position().z());

    }
    AlgebraicSymMatrix66 covT = AlgebraicMatrixID(); 
    covT *= 1e-20; // initialize to sigma=1e-10 .. should get overwhelmed by MULS

    CLHEP::Hep3Vector p3F,r3F; //propagated state
    AlgebraicSymMatrix66 covF;
    int charge = trkPDG > 0 ? -1 : 1; //works for muons

    nPoints_ = 0;
    pStatus = 0;
    loadNtVars(nPoints_, 0, pStatus, 0, p3T, r3T,  p3T, r3T, charge, covT); nPoints_++;
    

    FreeTrajectoryState ftsTrack = getFromCLHEP(p3T, r3T, charge, covT, &*bField);
    FreeTrajectoryState ftsStart = ftsTrack;
    //Create a SteppingHelixStateInfo object and initialize it with the ftsStart, which is loaded from the root file
    SteppingHelixStateInfo siStart(ftsStart);
    //Create another SteppingHelixStateInfo object, uninitialized
    SteppingHelixStateInfo siDest;
    //Create a TrajectoryStateOnSurface, this will be for our destination
    TrajectoryStateOnSurface tSOSDest;


   

    std::map<double, const GlobalSimHit*> simHitsByDistance;
    std::map<double, const GlobalSimHit*> simHitsByTof;
    for (std::vector<GlobalSimHit>::const_iterator allHitsCI = allSimHits.begin();
	 allHitsCI != allSimHits.end(); allHitsCI++){
      //Don't consider hits that aren't something...
      if (allHitsCI->hit->trackId() != trkInd ) continue;
      //Don't consider hits that aren't muons
      if (abs(allHitsCI->hit->particleType()) != 13) continue;
      //Don't consider hits with too low a momentum
      if (allHitsCI->p3.mag() < 0.5 ) continue;

      double distance = (allHitsCI->r3 - r3T).mag();
      double tof = allHitsCI->hit->timeOfFlight();
      simHitsByDistance[distance] = &*allHitsCI;
      simHitsByTof[tof] = &*allHitsCI;
    }








      if (testPCAPropagation_){
	FreeTrajectoryState ftsDest;
	GlobalPoint pDest1(10., 10., 0.);
	GlobalPoint pDest2(10., 10., 10.);

	//Here we're making a new object of the class "SteppingHelixPropagator"
	//We also 'put' in it the object we took from the root file with the mother class "Propagator"
	//What we do here is take the pointer pointing at the object "shPropAny" and cast it dynamically into
	//    the object shPropAnyCPtr

	const SteppingHelixPropagator* shPropAnyCPtr = 
	  dynamic_cast<const SteppingHelixPropagator*>(&*shPropAny);
	
	ftsDest = shPropAnyCPtr->propagate(ftsStart, pDest1);
	std::cout<<"----------------------------------------------"<<std::endl;
	ftsDest = shPropAnyCPtr->propagate(ftsStart, pDest1, pDest2);
	std::cout<<"----------------------------------------------"<<std::endl;
      }




      //now we are supposed to have a sorted list of hits
      std::map<double, const GlobalSimHit*>::const_iterator simHitsCI 
	= simHitsByDistance.begin();
      for (; simHitsCI != simHitsByDistance.end(); simHitsCI++){
	const GlobalSimHit* igHit = simHitsCI->second;
	const PSimHit* iHit = simHitsCI->second->hit;

	if (debug_){
	  LogTrace(metname)<< igHit->id.rawId()
			   <<" r3L:"<<iHit->localPosition()
			   <<" r3G:"<<igHit->r3
			   <<" p3L:"<<iHit->momentumAtEntry()
			   <<" p3G:"<<igHit->p3
			   <<" pId:"<<iHit->particleType()
			   <<" tId:"<<iHit->trackId()
			   <<std::endl;
	}

	if (debug_){
	  LogTrace(metname)<<"Will propagate to surface: "
			   <<igHit->surf->position()
			   <<" "<<igHit->surf->rotation()<<std::endl;
	}
	pStatus = 0;
	if (startFromPrevHit_){
	  if (simHitsCI != simHitsByDistance.begin()){
	    std::map<double, const GlobalSimHit*>::const_iterator simHitPrevCI = simHitsCI;
	    simHitPrevCI--;
	    const GlobalSimHit* gpHit = simHitPrevCI->second;
	    ftsStart = getFromCLHEP(gpHit->p3, gpHit->r3, charge, covT, &*bField);
	    siStart = SteppingHelixStateInfo(ftsTrack);
	  }
	}
	
	if (radX0CorrectionMode_ ){
	  const SteppingHelixPropagator* shPropCPtr = 
	    dynamic_cast<const SteppingHelixPropagator*>(&*shProp);
	  siDest = shPropCPtr->propagate(siStart, *igHit->surf);
	  if (siDest.isValid()){
	    siStart = siDest;
	    siStart.getFreeState(ftsStart);
	    getFromFTS(ftsStart, p3F, r3F, charge, covF);
	    pStatus = 0;
	  } else pStatus = 1;
	  if ( pStatus == 1 || (r3F- igHit->r3).mag() > FPRP_MISMATCH){ 
	    //start from the beginning if failed with previous
	    siStart = SteppingHelixStateInfo(ftsTrack);
	    pStatus = 1;
	  }
	} else {
	  // Propagate the hit ftsStart to tSOSDest
	  tSOSDest = shProp->propagate(ftsStart, *igHit->surf);
	  //Assuming its valid...
	  if (tSOSDest.isValid()){
	    ftsStart = *tSOSDest.freeState();
	    
	    getFromFTS(ftsStart, p3F, r3F, charge, covF);
	    pStatus = 0;
	  } else pStatus = 1;
	  if ( pStatus == 1 || (r3F- igHit->r3).mag() > FPRP_MISMATCH){ 
	    //start from the beginning if failed with previous
	    ftsStart = ftsTrack;
	    pStatus = 1;
	  }
	}
      

	if (debug_){
	  LogTrace(metname)<<"Got to "
			   <<" r3Prp:"<<r3F
			   <<" r3Hit:"<<igHit->r3
			   <<" p3Prp:"<<p3F
			   <<" p3Hit:"<<igHit->p3
			   <<" pPrp:"<<p3F.mag()
			   <<" pHit:"<<igHit->p3.mag()
			   <<std::endl;
	}
	loadNtVars(nPoints_, 0, pStatus, igHit->id.rawId(), 
		   p3F, r3F, igHit->p3, igHit->r3, charge, covF); nPoints_++;

      }//Close the loop over simHits sorted by distance

  }//Close the random brackets around this section that I prepended with an if statement so it only works if David's section is disabled


  if (tr_) tr_->Fill(); //fill this track prop info  
  }//Close the big loop over all the tracks

  
}

// "endJob" is an inherited method that you may implement to do post-EOF processing
// and produce final output.
//
void SteppingHelixPropagatorAnalyzer::endJob() {
  ntFile_->cd();
  tr_->Write();
  Eta_h->Write();
  Eta_gen_h->Write();
  z_r_hits->Write();
  delete ntFile_; ntFile_ = 0;
  
}

void SteppingHelixPropagatorAnalyzer::loadNtVars(int ind, int eType, int pStatus, int id,
						 const CLHEP::Hep3Vector& p3, const CLHEP::Hep3Vector& r3, 
						 const CLHEP::Hep3Vector& p3R, const CLHEP::Hep3Vector& r3R, 
						 int charge, const AlgebraicSymMatrix66& cov){
  p3_[ind][eType*3+0] = p3.x();  p3_[ind][eType*3+1] = p3.y();  p3_[ind][eType*3+2] = p3.z();
  r3_[ind][eType*3+0] = r3.x();  r3_[ind][eType*3+1] = r3.y();  r3_[ind][eType*3+2] = r3.z();
  id_[ind] = id;
  p3R_[ind][0] = p3R.x();  p3R_[ind][1] = p3R.y();  p3R_[ind][2] = p3R.z();
  r3R_[ind][0] = r3R.x();  r3R_[ind][1] = r3R.y();  r3R_[ind][2] = r3R.z();
  int flatInd = 0;
  for (int i =1; i <= cov.kRows; i++) 
    for (int j=1; j<=i;j++){
      covFlat_[ind][flatInd] = cov(i-1,j-1);
      flatInd++;
    }
  q_[ind] = charge;
  eType_[ind] = eType;
  pStatus_[ind][eType] = pStatus;

}

void SteppingHelixPropagatorAnalyzer::loadNtVarsDavid(int ind, int eType, int pStatus, int id,
						      const CLHEP::Hep3Vector& p3, const CLHEP::Hep3Vector& r3, 
						      const CLHEP::Hep3Vector& r3S, 
						      const CLHEP::Hep3Vector& p3R, const CLHEP::Hep3Vector& r3R,
						      bool Matched,
						      const CLHEP::Hep3Vector& p3Reco, const CLHEP::Hep3Vector& r3Reco,
						      int charge, const AlgebraicSymMatrix66& cov,const AlgebraicSymMatrix66& covReco,
						      int NHits,
						      const CLHEP::Hep3Vector& p3_B0, const CLHEP::Hep3Vector& r3_B0,
						      const AlgebraicSymMatrix66& covReco_B0){
  p3_[ind][eType*3+0] = p3.x();  p3_[ind][eType*3+1] = p3.y();  p3_[ind][eType*3+2] = p3.z();
  r3_[ind][eType*3+0] = r3.x();  r3_[ind][eType*3+1] = r3.y();  r3_[ind][eType*3+2] = r3.z();
  r3S_[ind][0] = r3S.x();  r3S_[ind][1] = r3S.y();  r3S_[ind][2] = r3S.z();
  id_[ind] = id;
  p3R_[ind][0] = p3R.x();  p3R_[ind][1] = p3R.y();  p3R_[ind][2] = p3R.z();
  r3R_[ind][0] = r3R.x();  r3R_[ind][1] = r3R.y();  r3R_[ind][2] = r3R.z();
  p3Reco_[ind][0] = p3Reco.x();  p3Reco_[ind][1] = p3Reco.y();  p3Reco_[ind][2] = p3Reco.z();
  r3Reco_[ind][0] = r3Reco.x();  r3Reco_[ind][1] = r3Reco.y();  r3Reco_[ind][2] = r3Reco.z();
  NHits_[ind] = NHits;
  //std::cout<<r3S_[ind][0]<<std::endl;
  //std::cout<<r3S_[ind][1]<<std::endl;
  //std::cout<<r3S_[ind][2]<<std::endl;
  // if (ind>0){
  // std::cout<<r3_[ind][0]<<", "<<r3Reco_[ind][0]<<", "<<ind<<std::endl;
  // std::cout<<r3_[ind][1]<<", "<<r3Reco_[ind][1]<<", "<<ind<<std::endl;
  //std::cout<<r3S_[ind][2]<<", "<<r3S_[ind][2]<<", "<<ind<<std::endl;}
  Matched_[ind] = Matched;
  int flatInd = 0;
  for (int i =1; i <= cov.kRows; i++) 
    for (int j=1; j<=i;j++){
      covFlat_[ind][flatInd] = cov(i-1,j-1);
      flatInd++;
    }
  flatInd = 0;
  for (int i =1; i <= covReco.kRows; i++) 
    for (int j=1; j<=i;j++){
      covRecoFlat_[ind][flatInd] = covReco(i-1,j-1);
      flatInd++;
    }
  q_[ind] = charge;
  eType_[ind] = eType;
  pStatus_[ind][eType] = pStatus;

  p3_B0_[ind][0] = p3_B0.x();  p3_B0_[ind][1] = p3_B0.y();  p3_B0_[ind][2] = p3_B0.z();
  r3_B0_[ind][0] = r3_B0.x();  r3_B0_[ind][1] = r3_B0.y();  r3_B0_[ind][2] = r3_B0.z();
  std::cout<<r3_B0_[ind][0]<<", "<<r3_B0_[ind][1]<<", "<<r3_B0_[ind][2]<<std::endl;
  flatInd = 0;
  for (int i =1; i <= covReco_B0.kRows; i++) 
    for (int j=1; j<=i;j++){
      covB0Flat_[ind][flatInd] = covReco_B0(i-1,j-1);
      flatInd++;
    }
}

FreeTrajectoryState
SteppingHelixPropagatorAnalyzer::getFromCLHEP(const CLHEP::Hep3Vector& p3, const CLHEP::Hep3Vector& r3, 
					      int charge, const AlgebraicSymMatrix66& cov,
					      const MagneticField* field){

  GlobalVector p3GV(p3.x(), p3.y(), p3.z());
  GlobalPoint r3GP(r3.x(), r3.y(), r3.z());
  GlobalTrajectoryParameters tPars(r3GP, p3GV, charge, field);

  CartesianTrajectoryError tCov(cov);
  
  return cov.kRows == 6 ? FreeTrajectoryState(tPars, tCov) : FreeTrajectoryState(tPars) ;
}

FreeTrajectoryState
SteppingHelixPropagatorAnalyzer::getFromCLHEP(const CLHEP::Hep3Vector& p3, const CLHEP::Hep3Vector& r3, 
					      int charge, const AlgebraicSymMatrix55& cov,
					      const MagneticField* field){

  GlobalVector p3GV(p3.x(), p3.y(), p3.z());
  GlobalPoint r3GP(r3.x(), r3.y(), r3.z());
  GlobalTrajectoryParameters tPars(r3GP, p3GV, charge, field);

  CurvilinearTrajectoryError tCov(cov);
  
  return cov.kRows == 5 ? FreeTrajectoryState(tPars, tCov) : FreeTrajectoryState(tPars) ;
}

void SteppingHelixPropagatorAnalyzer::getFromFTS(const FreeTrajectoryState& fts,
						 CLHEP::Hep3Vector& p3, CLHEP::Hep3Vector& r3, 
						 int& charge, AlgebraicSymMatrix66& cov){
  GlobalVector p3GV = fts.momentum();
  GlobalPoint r3GP = fts.position();

  p3.set(p3GV.x(), p3GV.y(), p3GV.z());
  r3.set(r3GP.x(), r3GP.y(), r3GP.z());
  
  charge = fts.charge();
  cov = fts.hasError() ? fts.cartesianError().matrix() : AlgebraicSymMatrix66();

}

void SteppingHelixPropagatorAnalyzer
::addPSimHits(const edm::Event& iEvent,
	      const std::string instanceName, 
	      const edm::ESHandle<GlobalTrackingGeometry>& geom,
	      std::vector<SteppingHelixPropagatorAnalyzer::GlobalSimHit>& hits) const {
  static std::string metname = "SteppingHelixPropagatorAnalyzer";
  edm::Handle<edm::PSimHitContainer> handle;
  iEvent.getByLabel(g4SimName_, instanceName, handle);
  if (! handle.isValid() ){
    std::cout<<"No hits found"<<std::endl;
    return;
  }
  if (debug_){
    LogTrace(metname)<<"Got "<<instanceName<<" of size "<< handle->size()<<std::endl;
  }  

  edm::PSimHitContainer::const_iterator pHits_CI = handle->begin();
  for (; pHits_CI != handle->end(); pHits_CI++){
    int dtId = pHits_CI->detUnitId(); 
    DetId wId(dtId);

    const GeomDet* layer = geom->idToDet(wId);

    GlobalSimHit gHit;
    gHit.hit = &*pHits_CI;
    gHit.surf = &layer->surface();
    gHit.id = wId;

    //place the hit onto the surface
    float dzFrac = gHit.hit->entryPoint().z()/(gHit.hit->exitPoint().z()-gHit.hit->entryPoint().z());
    GlobalPoint r3Hit = gHit.surf->toGlobal(gHit.hit->entryPoint()-dzFrac*(gHit.hit->exitPoint()-gHit.hit->entryPoint()));
    gHit.r3.set(r3Hit.x(), r3Hit.y(), r3Hit.z());
    GlobalVector p3Hit = gHit.surf->toGlobal(gHit.hit->momentumAtEntry());
    gHit.p3.set(p3Hit.x(), p3Hit.y(), p3Hit.z());
    hits.push_back(gHit);
  }
}


//define this as a plug-in
DEFINE_FWK_MODULE(SteppingHelixPropagatorAnalyzer);
