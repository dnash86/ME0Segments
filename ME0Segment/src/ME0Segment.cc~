/** \file ME0Segment.cc
 *
 *  $Date: 2013/04/22 22:41:33 $
 *  \author Matteo Sani
 */

#include <ME0Reconstruction/ME0Segment/interface/ME0Segment.h>
#include <iostream>

ME0Segment::ME0Segment(const std::vector<const ME0RecHit2D*>& proto_segment, LocalPoint origin, 
	LocalVector direction, AlgebraicSymMatrix errors, double chi2) : 
  RecSegment(buildDetId(proto_segment.front()->cscDetId())),
  theOrigin(origin), 
  theLocalDirection(direction), theCovMatrix(errors), theChi2(chi2), aME11a_duplicate(false) {

  for(unsigned int i=0; i<proto_segment.size(); ++i)
    theME0RecHits.push_back(*proto_segment[i]);
}

ME0Segment::~ME0Segment() {}

std::vector<const TrackingRecHit*> ME0Segment::recHits() const{
  std::vector<const TrackingRecHit*> pointersOfRecHits;
  for (std::vector<ME0RecHit2D>::const_iterator irh = theME0RecHits.begin(); irh!=theME0RecHits.end(); ++irh) {
    pointersOfRecHits.push_back(&(*irh));
  }
  return pointersOfRecHits;
}

std::vector<TrackingRecHit*> ME0Segment::recHits() {
  
  std::vector<TrackingRecHit*> pointersOfRecHits;
  for (std::vector<ME0RecHit2D>::iterator irh = theME0RecHits.begin(); irh!=theME0RecHits.end(); ++irh) {
    pointersOfRecHits.push_back(&(*irh));
  }
  return pointersOfRecHits;
}

LocalError ME0Segment::localPositionError() const {
  return LocalError(theCovMatrix[2][2], theCovMatrix[2][3], theCovMatrix[3][3]);
}

LocalError ME0Segment::localDirectionError() const {
  return LocalError(theCovMatrix[0][0], theCovMatrix[0][1], theCovMatrix[1][1]); 
}


AlgebraicVector ME0Segment::parameters() const {
  // For consistency with DT and what we require for the TrackingRecHit interface,
  // the order of the parameters in the returned vector should be (dx/dz, dy/dz, x, z)
  
  AlgebraicVector result(4);

  result[0] = theLocalDirection.x()/theLocalDirection.z();
  result[1] = theLocalDirection.y()/theLocalDirection.z();    
  result[2] = theOrigin.x();
  result[3] = theOrigin.y();

  return result;
}


AlgebraicMatrix ME0Segment::projectionMatrix() const {
  static AlgebraicMatrix theProjectionMatrix( 4, 5, 0);
  static bool isInitialized = false;
  if (!isInitialized) {
    theProjectionMatrix[0][1] = 1;
    theProjectionMatrix[1][2] = 1;
    theProjectionMatrix[2][3] = 1;
    theProjectionMatrix[3][4] = 1;
    isInitialized=true;
  }    
  return theProjectionMatrix;
}

void ME0Segment::setDuplicateSegments(std::vector<ME0Segment*> & duplicates){
  theDuplicateSegments.clear();
  for(unsigned int i=0; i<duplicates.size(); ++i){
    theDuplicateSegments.push_back(*duplicates[i]);
    //avoid copying duplicates of duplicates of duplicates...
    theDuplicateSegments.back().theDuplicateSegments.resize(0);
 }
}

bool ME0Segment::testSharesAllInSpecificRecHits( const std::vector<ME0RecHit2D>& specificRecHits_1,
						 const std::vector<ME0RecHit2D>& specificRecHits_2,
						 ME0RecHit2D::SharedInputType sharesInput) const{
  const std::vector<ME0RecHit2D> * rhContainer_1 = &specificRecHits_1;
  const std::vector<ME0RecHit2D> * rhContainer_2 = &specificRecHits_2;
  if(specificRecHits_1.size()>specificRecHits_2.size()){
    rhContainer_2 = &specificRecHits_1;
    rhContainer_1 = &specificRecHits_2;
  }
  //
  bool shareConditionPassed = true;
  for ( std::vector<ME0RecHit2D>::const_iterator itRH = rhContainer_1->begin();
	itRH != rhContainer_1->end(); ++itRH) {
    const  ME0RecHit2D *firstRecHit = &(*itRH);
    bool sharedHit = false;
    for ( std::vector<ME0RecHit2D>::const_iterator itRH2 = rhContainer_2->begin();
	  itRH2 != rhContainer_2->end(); ++itRH2) {
      if(itRH2->sharesInput(firstRecHit,sharesInput)){
	sharedHit = true;
	break;
      }
    }
    if(!sharedHit){
      shareConditionPassed = false;
      break;
    }
  }
  return shareConditionPassed;
}

//bool ME0Segment::sharesRecHits(ME0Segment  & anotherSegment, ME0RecHit2D::SharedInputType sharesInput){
  // 2 tracks through a chamber leave 4 rechits per layer (2 strips x 2 wire groups) 
  // this function finds segments sharing wires or strips (first the rechits by sharesInput() )
  // there could probably be more complicated cases with partial sharing (but this needs studies)
  //
  //return testSharesAllInSpecificRecHits( theME0RecHits , anotherSegment.specificRecHits(), sharesInput);  
//}

bool ME0Segment::sharesRecHits(const ME0Segment  & anotherSegment, ME0RecHit2D::SharedInputType sharesInput) const {
  return testSharesAllInSpecificRecHits( theME0RecHits , anotherSegment.specificRecHits(), sharesInput);  
}

//
bool ME0Segment::sharesRecHits(const ME0Segment  & anotherSegment) const {
  if(testSharesAllInSpecificRecHits( theME0RecHits , anotherSegment.specificRecHits(), ME0RecHit2D::someWires) &&
     testSharesAllInSpecificRecHits( theME0RecHits , anotherSegment.specificRecHits(), ME0RecHit2D::someStrips)){
    return true;
  }
  else{
    return false;
  }
}
//

float ME0Segment::time() const {
  float averageTime=0;
  std::vector<float> wireTimes;
  for (std::vector<ME0RecHit2D>::const_iterator itRH = theME0RecHits.begin();
       itRH != theME0RecHits.end(); ++itRH) {
    const  ME0RecHit2D *recHit = &(*itRH);
    averageTime+=recHit->tpeak();
    averageTime+=recHit->wireTime();
    wireTimes.push_back(recHit->wireTime());
  }
  averageTime=averageTime/(2*theME0RecHits.size());

  //The wire times have a long tail that has to be pruned.  The strip times (tpeak) are fine
  bool modified=true;
  while(modified) {
    modified=false;
    double maxDiff=-1;
    std::vector<float>::iterator maxHit;
    for (std::vector<float>::iterator itWT=wireTimes.begin();
	 itWT!=wireTimes.end(); ++itWT) {
      float diff=fabs(*itWT-averageTime);
      if (diff>maxDiff) {
	maxDiff=diff;
	maxHit=itWT;
      }
    }
    if (maxDiff>26) {
      int N=theME0RecHits.size()+wireTimes.size();
      averageTime=(averageTime*N-(*maxHit))/(N-1);
      wireTimes.erase(maxHit);
      modified=true;
    }
  }
  return averageTime;
}

//
void ME0Segment::print() const {
  std::cout << *this << std::endl;
}

std::ostream& operator<<(std::ostream& os, const ME0Segment& seg) {
  os << "ME0Segment: local pos = " << seg.localPosition() << 
    " posErr = (" << sqrt(seg.localPositionError().xx())<<","<<sqrt(seg.localPositionError().yy())<<
    "0,)\n"<<
    "            dir = " << seg.localDirection() <<
    " dirErr = (" << sqrt(seg.localDirectionError().xx())<<","<<sqrt(seg.localDirectionError().yy())<<
    "0,)\n"<<
    "            chi2/ndf = " << seg.chi2()/double(seg.degreesOfFreedom()) << 
    " #rechits = " << seg.specificRecHits().size()<<
    " ME1/1a duplicates : "<<seg.duplicateSegments().size();
  return os;  
}

/*
const ME0Chamber* ME0Segment::chamber() const { return theChamber; }
*/
